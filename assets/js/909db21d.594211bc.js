"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[3470],{3905:function(e,t,n){n.d(t,{Zo:function(){return d},kt:function(){return p}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),h=c(n),p=r,m=h["".concat(l,".").concat(p)]||h[p]||u[p]||o;return n?a.createElement(m,i(i({ref:t},d),{},{components:n})):a.createElement(m,i({ref:t},d))}));function p(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var c=2;c<o;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},1180:function(e,t,n){n.r(t),n.d(t,{assets:function(){return d},contentTitle:function(){return l},default:function(){return p},frontMatter:function(){return s},metadata:function(){return c},toc:function(){return u}});var a=n(7462),r=n(3366),o=(n(7294),n(3905)),i=["components"],s={description:"Tutorial on how to transfer ERC-20 tokens to another wallet or smart contract with Go."},l="Transferring Tokens (ERC-20)",c={unversionedId:"en/transfer-tokens/README",id:"en/transfer-tokens/README",title:"Transferring Tokens (ERC-20)",description:"Tutorial on how to transfer ERC-20 tokens to another wallet or smart contract with Go.",source:"@site/docs/en/transfer-tokens/README.md",sourceDirName:"en/transfer-tokens",slug:"/en/transfer-tokens/",permalink:"/ethereum-development-with-go-book/docs/en/transfer-tokens/",editUrl:"https://github.com/mhxw/ethereum-development-with-go-book/tree/dev/docs/en/transfer-tokens/README.md",tags:[],version:"current",frontMatter:{description:"Tutorial on how to transfer ERC-20 tokens to another wallet or smart contract with Go."},sidebar:"en",previous:{title:"Transferring ETH",permalink:"/ethereum-development-with-go-book/docs/en/transfer-eth/"},next:{title:"Subscribing to New Blocks",permalink:"/ethereum-development-with-go-book/docs/en/block-subscribe/"}},d={},u=[{value:"Creating a Token for testing",id:"creating-a-token-for-testing",level:2},{value:"ETH value and destination address",id:"eth-value-and-destination-address",level:2},{value:"Forming the data field",id:"forming-the-data-field",level:2},{value:"Set gas limit",id:"set-gas-limit",level:2},{value:"Create transaction",id:"create-transaction",level:2},{value:"Full code",id:"full-code",level:3}],h={toc:u};function p(e){var t=e.components,n=(0,r.Z)(e,i);return(0,o.kt)("wrapper",(0,a.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"transferring-tokens-erc-20"},"Transferring Tokens (ERC-20)"),(0,o.kt)("p",null,"This section will walk you through on how to transfer ERC-20 tokens. To learn how to transfer other types of tokens that are non-ERC-20 compliant check out the ",(0,o.kt)("a",{parentName:"p",href:"../smart-contracts"},"section on smart contracts")," to learn how to interact with smart contracts."),(0,o.kt)("p",null,"To transfer ERC-20 tokens, we'll need to broadcast a transaction to the blockchain just like before, but with a few changed parameters:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Instead of setting a ",(0,o.kt)("inlineCode",{parentName:"li"},"value")," for the broadcasted transaction, we'll need to embed the value of tokens to transfer in the ",(0,o.kt)("inlineCode",{parentName:"li"},"data")," send in the transaction."),(0,o.kt)("li",{parentName:"ul"},"Construct a contract function call and embed it in the ",(0,o.kt)("inlineCode",{parentName:"li"},"data")," field of the transaction we're broadcasting to the blockchain.")),(0,o.kt)("p",null,"We'll assume that you've already completed the previous ",(0,o.kt)("a",{parentName:"p",href:"../transfer-eth"},"section on transferring ETH"),", and have a Go application that has:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Connected a client."),(0,o.kt)("li",{parentName:"ol"},"Loaded your account private key."),(0,o.kt)("li",{parentName:"ol"},"Configured the gas price to use for your transaction.")),(0,o.kt)("h2",{id:"creating-a-token-for-testing"},"Creating a Token for testing"),(0,o.kt)("p",null,"You can create a token using the Token Factory ",(0,o.kt)("a",{parentName:"p",href:"https://tokenfactory.surge.sh/"},"https://tokenfactory.surge.sh"),", a website for conveniently deploying ERC-20 token contracts, to follow the examples in this guide."),(0,o.kt)("p",null,"When you create your ERC-20 Token, be sure to note down the ",(0,o.kt)("strong",{parentName:"p"},"address of the token contract"),"."),(0,o.kt)("p",null,"For demonstration purposes, I've created a token (HelloToken HTN) using the Token Factory and deployed it to the Rinkeby testnet at the token contract address ",(0,o.kt)("inlineCode",{parentName:"p"},"0x28b149020d2152179873ec60bed6bf7cd705775d"),"."),(0,o.kt)("p",null,"You can check it out with a Web3-enabled browser here (make sure to be connected to the Rinkeby testnet in MetaMask): ",(0,o.kt)("a",{parentName:"p",href:"https://tokenfactory.surge.sh/#/token/0x28b149020d2152179873ec60bed6bf7cd705775d"},"https://tokenfactory.surge.sh/#/token/0x28b149020d2152179873ec60bed6bf7cd705775d")),(0,o.kt)("h2",{id:"eth-value-and-destination-address"},"ETH value and destination address"),(0,o.kt)("p",null,"First, we'll set a few variables."),(0,o.kt)("p",null,"Set the ",(0,o.kt)("inlineCode",{parentName:"p"},"value")," of the transaction to 0."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"value := big.NewInt(0)\n")),(0,o.kt)("p",null,"This ",(0,o.kt)("inlineCode",{parentName:"p"},"value")," is the amount of ETH to be transferred for this transaction, which should be ",(0,o.kt)("inlineCode",{parentName:"p"},"0")," since we're transferring ERC-20 Tokens and not ETH. We'll set the value of Tokens to be transferred in the ",(0,o.kt)("inlineCode",{parentName:"p"},"data")," field later."),(0,o.kt)("p",null,"Then, store the address you'll be sending tokens to in a variable."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'toAddress := common.HexToAddress("0x4592d8f8d7b001e72cb26a73e4fa1806a51ac79d")\n')),(0,o.kt)("h2",{id:"forming-the-data-field"},"Forming the data field"),(0,o.kt)("p",null,"Now the fun part. We'll need to figure out what goes into the ",(0,o.kt)("inlineCode",{parentName:"p"},"data")," field of the transaction. This is the message that we broadcast to the blockchain as part of the transaction."),(0,o.kt)("p",null,"To make a token transfer, we need to use this data field to invoke a function on the smart contract. For more information on the functions available on an ERC-20 token contract, see the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md"},"ERC-20 Token Standard specification"),"."),(0,o.kt)("p",null,"To transfer tokens from our active account to another, we need to invoke the ",(0,o.kt)("inlineCode",{parentName:"p"},"transfer()")," function in our ERC-20 token in our transactions data field. We do this by doing the following:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Figure out the function signature of the ",(0,o.kt)("inlineCode",{parentName:"li"},"transfer()")," smart contract function we'll be calling."),(0,o.kt)("li",{parentName:"ol"},"Figure out the inputs for the function \u2014 the ",(0,o.kt)("inlineCode",{parentName:"li"},"address")," of the token recipients, and the ",(0,o.kt)("inlineCode",{parentName:"li"},"value")," of tokens to be transferred."),(0,o.kt)("li",{parentName:"ol"},"Get the first 8 characters (4 bytes) of the Keccak256 hash of that function signature. This is the ",(0,o.kt)("em",{parentName:"li"},"method ID")," of the contract function we're invoking."),(0,o.kt)("li",{parentName:"ol"},"Zero-pad (on the left) the inputs of our function call \u2014 the ",(0,o.kt)("inlineCode",{parentName:"li"},"address")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"value"),". These input values need to be 256-bits (32 bytes) long.")),(0,o.kt)("p",null,"First, let's assign the token contract address to a variable."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'tokenAddress := common.HexToAddress("0x28b149020d2152179873ec60bed6bf7cd705775d")\n')),(0,o.kt)("p",null,"Next, we need to form the smart contract function call. The signature of the function we'll be calling is the ",(0,o.kt)("inlineCode",{parentName:"p"},"transfer()")," function in the ERC-20 specification, and the types of the argument we'll be passing to it. The first argument type is ",(0,o.kt)("inlineCode",{parentName:"p"},"address")," (the address to which we're sending tokens), and the second argument's type is ",(0,o.kt)("inlineCode",{parentName:"p"},"uint256")," (the amount of tokens to send). The result is the string ",(0,o.kt)("inlineCode",{parentName:"p"},"transfer(address,uint256)")," (no spaces!)."),(0,o.kt)("p",null,"We need this function signature as a byte slice, which we assign to ",(0,o.kt)("inlineCode",{parentName:"p"},"transferFnSignature"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'transferFnSignature := []byte("transfer(address,uint256)") // do not include spaces in the string\n')),(0,o.kt)("p",null,"We then need to get the ",(0,o.kt)("inlineCode",{parentName:"p"},"methodID")," of our function. To do this, we'll import the ",(0,o.kt)("inlineCode",{parentName:"p"},"crypto/sha3")," to generate the Keccak256 hash of the function signature. The first 4 bytes of the resulting hash is the ",(0,o.kt)("inlineCode",{parentName:"p"},"methodID"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"hash := sha3.NewLegacyKeccak256()\nhash.Write(transferFnSignature)\nmethodID := hash.Sum(nil)[:4]\nfmt.Println(hexutil.Encode(methodID)) // 0xa9059cbb\n")),(0,o.kt)("p",null,"Next we'll zero pad (to the left) the account address we're sending tokens. The resulting byte slice must be 32 bytes long:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"paddedAddress := common.LeftPadBytes(toAddress.Bytes(), 32)\nfmt.Println(hexutil.Encode(paddedAddress)) // 0x0000000000000000000000004592d8f8d7b001e72cb26a73e4fa1806a51ac79d\n")),(0,o.kt)("p",null,"Next we'll set the value tokens to send as a ",(0,o.kt)("inlineCode",{parentName:"p"},"*big.Int")," number. Note that the denomination used here is determined by the token contract that you're interacting with, and ",(0,o.kt)("strong",{parentName:"p"},"not")," in ETH or wei."),(0,o.kt)("p",null,"For example, if we were working with TokenA where 1 token is set as the smallest unit of TokenA (i.e. the ",(0,o.kt)("inlineCode",{parentName:"p"},"decimal()")," value of the token contract is ",(0,o.kt)("inlineCode",{parentName:"p"},"0"),"; for more information, see the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md"},"ERC-20 Token Standard specification"),"), then ",(0,o.kt)("inlineCode",{parentName:"p"},"amount := big.NewInt(1000)")," would set ",(0,o.kt)("inlineCode",{parentName:"p"},"amount")," to ",(0,o.kt)("inlineCode",{parentName:"p"},"1000")," units of TokenA."),(0,o.kt)("p",null,"The example token we're using, HelloToken, uses 18 decimals which is standard practice for ERC-20 tokens. This means that in order to represent 1 token we have to do the calculation ",(0,o.kt)("em",{parentName:"p"},"amount * 10^18"),". In this example we'll use 1,000 tokens so we'll need to calculate ",(0,o.kt)("em",{parentName:"p"},"1000 * 10^18")," which is ",(0,o.kt)("em",{parentName:"p"},"1e+21")," or ",(0,o.kt)("em",{parentName:"p"},"1000000000000000000000"),". This is the value the smart contract understands as 1,000 tokens from a user representation."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'amount := new(big.Int)\namount.SetString("1000000000000000000000", 10) // sets the value to 1000 tokens, in the token denomination\n')),(0,o.kt)("p",null,"There are utility functions available in the ",(0,o.kt)("a",{parentName:"p",href:"../util-go"},"utils")," section to easily do these conversions."),(0,o.kt)("p",null,"Left padding to 32 bytes will also be required for the amount since the EVM use 32 byte wide data structures."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"paddedAmount := common.LeftPadBytes(amount.Bytes(), 32)\nfmt.Println(hexutil.Encode(paddedAmount))  // 0x00000000000000000000000000000000000000000000003635c9adc5dea00000\n")),(0,o.kt)("p",null,"Now we concanate the method ID, padded address, and padded amount into a byte slice that will be our data field."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"var data []byte\ndata = append(data, methodID...)\ndata = append(data, paddedAddress...)\ndata = append(data, paddedAmount...)\n")),(0,o.kt)("h2",{id:"set-gas-limit"},"Set gas limit"),(0,o.kt)("p",null,"The gas limit will depend on the size of the transaction data and computational steps that the smart contract has to perform. Fortunately the client provides the ",(0,o.kt)("inlineCode",{parentName:"p"},"EstimateGas")," method which is able to esimate the gas for us based on the most recent state of the blockchain. This function takes a ",(0,o.kt)("inlineCode",{parentName:"p"},"CallMsg")," struct from the ",(0,o.kt)("inlineCode",{parentName:"p"},"ethereum")," package where we specify the data and the address of the token contract to which we're sending the function call message. It'll return the estimated gas limit units we'll use to generate the complete transaction."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"gasLimit, err := client.EstimateGas(context.Background(), ethereum.CallMsg{\n  To:   &tokenAddress,\n  Data: data,\n})\nif err != nil {\n  log.Fatal(err)\n}\n\nfmt.Println(gasLimit) // 23256\n")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"NOTE"),": The gas limit set by the ",(0,o.kt)("inlineCode",{parentName:"p"},"EstimateGas()")," method is based on the current state of the blockchain, and is just an ",(0,o.kt)("em",{parentName:"p"},"estimate"),". If your transactions are constantly failing, or if you prefer to have full control over the amount of gas your application spends, you may want to set this value manually."),(0,o.kt)("h2",{id:"create-transaction"},"Create transaction"),(0,o.kt)("p",null,"Now we have all the information we need to generate the transaction."),(0,o.kt)("p",null,"We'll create a transaction similar the one we used in ",(0,o.kt)("a",{parentName:"p",href:"../transfer-eth"},"section on transferring ETH"),", EXCEPT that the ",(0,o.kt)("em",{parentName:"p"},"to")," field should contain the token smart contract address, and the value field should be set to ",(0,o.kt)("inlineCode",{parentName:"p"},"0")," since we're not transferring ETH. This is a gotcha that confuses people."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"tx := types.NewTransaction(nonce, tokenAddress, value, gasLimit, gasPrice, data)\n")),(0,o.kt)("p",null,"The next step is to sign the transaction with the private key of the sender. The ",(0,o.kt)("inlineCode",{parentName:"p"},"SignTx")," method requires the EIP155 signer, which we derive the chain ID from the client."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"chainID, err := client.NetworkID(context.Background())\nif err != nil {\n  log.Fatal(err)\n}\n\nsignedTx, err := types.SignTx(tx, types.NewEIP155Signer(chainID), privateKey)\nif err != nil {\n  log.Fatal(err)\n}\n")),(0,o.kt)("p",null,"And finally, broadcast the transaction:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'err = client.SendTransaction(context.Background(), signedTx)\nif err != nil {\n  log.Fatal(err)\n}\n\nfmt.Printf("tx sent: %s", signedTx.Hash().Hex()) // tx sent: 0xa56316b637a94c4cc0331c73ef26389d6c097506d581073f927275e7a6ece0bc\n')),(0,o.kt)("p",null,"You can check the progress on Etherscan: ",(0,o.kt)("a",{parentName:"p",href:"https://rinkeby.etherscan.io/tx/0xa56316b637a94c4cc0331c73ef26389d6c097506d581073f927275e7a6ece0bc"},"https://rinkeby.etherscan.io/tx/0xa56316b637a94c4cc0331c73ef26389d6c097506d581073f927275e7a6ece0bc")),(0,o.kt)("p",null,"To learn how to load and interact with an ERC20 smart contract, check out the ",(0,o.kt)("a",{parentName:"p",href:"../smart-contract-read-erc20"},"section on ERC20 token smart contracts"),"."),(0,o.kt)("hr",null),(0,o.kt)("h3",{id:"full-code"},"Full code"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://github.com/mhxw/ethereum-development-with-go-book/blob/main/code/transfer_tokens.go"},"transfer_tokens.go")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nimport (\n    "context"\n    "crypto/ecdsa"\n    "fmt"\n    "log"\n    "math/big"\n\n    "golang.org/x/crypto/sha3"\n    "github.com/ethereum/go-ethereum"\n    "github.com/ethereum/go-ethereum/common"\n    "github.com/ethereum/go-ethereum/common/hexutil"\n    "github.com/ethereum/go-ethereum/core/types"\n    "github.com/ethereum/go-ethereum/crypto"\n    "github.com/ethereum/go-ethereum/ethclient"\n)\n\nfunc main() {\n    client, err := ethclient.Dial("https://rinkeby.infura.io")\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    privateKey, err := crypto.HexToECDSA("fad9c8855b740a0b7ed4c221dbad0f33a83a49cad6b3fe8d5817ac83d38b6a19")\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    publicKey := privateKey.Public()\n    publicKeyECDSA, ok := publicKey.(*ecdsa.PublicKey)\n    if !ok {\n        log.Fatal("cannot assert type: publicKey is not of type *ecdsa.PublicKey")\n    }\n\n    fromAddress := crypto.PubkeyToAddress(*publicKeyECDSA)\n    nonce, err := client.PendingNonceAt(context.Background(), fromAddress)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    value := big.NewInt(0) // in wei (0 eth)\n    gasPrice, err := client.SuggestGasPrice(context.Background())\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    toAddress := common.HexToAddress("0x4592d8f8d7b001e72cb26a73e4fa1806a51ac79d")\n    tokenAddress := common.HexToAddress("0x28b149020d2152179873ec60bed6bf7cd705775d")\n\n    transferFnSignature := []byte("transfer(address,uint256)")\n    hash := sha3.NewLegacyKeccak256()\n    hash.Write(transferFnSignature)\n    methodID := hash.Sum(nil)[:4]\n    fmt.Println(hexutil.Encode(methodID)) // 0xa9059cbb\n\n    paddedAddress := common.LeftPadBytes(toAddress.Bytes(), 32)\n    fmt.Println(hexutil.Encode(paddedAddress)) // 0x0000000000000000000000004592d8f8d7b001e72cb26a73e4fa1806a51ac79d\n\n    amount := new(big.Int)\n    amount.SetString("1000000000000000000000", 10) // sets the value to 1000 tokens, in the token denomination\n\n    paddedAmount := common.LeftPadBytes(amount.Bytes(), 32)\n    fmt.Println(hexutil.Encode(paddedAmount)) // 0x00000000000000000000000000000000000000000000003635c9adc5dea00000\n\n    var data []byte\n    data = append(data, methodID...)\n    data = append(data, paddedAddress...)\n    data = append(data, paddedAmount...)\n\n    gasLimit, err := client.EstimateGas(context.Background(), ethereum.CallMsg{\n        To:   &tokenAddress,\n        Data: data,\n    })\n    if err != nil {\n        log.Fatal(err)\n    }\n    fmt.Println(gasLimit) // 23256\n\n    tx := types.NewTransaction(nonce, tokenAddress, value, gasLimit, gasPrice, data)\n\n    chainID, err := client.NetworkID(context.Background())\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    signedTx, err := types.SignTx(tx, types.NewEIP155Signer(chainID), privateKey)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    err = client.SendTransaction(context.Background(), signedTx)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    fmt.Printf("tx sent: %s", signedTx.Hash().Hex()) // tx sent: 0xa56316b637a94c4cc0331c73ef26389d6c097506d581073f927275e7a6ece0bc\n}\n')))}p.isMDXComponent=!0}}]);