"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[6981],{3905:function(e,n,t){t.d(n,{Zo:function(){return u},kt:function(){return p}});var r=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function c(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var l=r.createContext({}),s=function(e){var n=r.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},u=function(e){var n=s(e.components);return r.createElement(l.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},m=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,u=c(e,["components","mdxType","originalType","parentName"]),m=s(t),p=a,g=m["".concat(l,".").concat(p)]||m[p]||d[p]||i;return t?r.createElement(g,o(o({ref:n},u),{},{components:t})):r.createElement(g,o({ref:n},u))}));function p(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=t.length,o=new Array(i);o[0]=m;var c={};for(var l in n)hasOwnProperty.call(n,l)&&(c[l]=n[l]);c.originalType=e,c.mdxType="string"==typeof e?e:a,o[1]=c;for(var s=2;s<i;s++)o[s]=t[s];return r.createElement.apply(null,o)}return r.createElement.apply(null,t)}m.displayName="MDXCreateElement"},1078:function(e,n,t){t.r(n),t.d(n,{assets:function(){return u},contentTitle:function(){return l},default:function(){return p},frontMatter:function(){return c},metadata:function(){return s},toc:function(){return d}});var r=t(7462),a=t(3366),i=(t(7294),t(3905)),o=["components"],c={description:"Tutorial on how to set up a simulated backend as your client to test your Ethereum application with Go."},l="Using a Simulated Client",s={unversionedId:"en/client-simulated/README",id:"en/client-simulated/README",title:"Using a Simulated Client",description:"Tutorial on how to set up a simulated backend as your client to test your Ethereum application with Go.",source:"@site/docs/en/client-simulated/README.md",sourceDirName:"en/client-simulated",slug:"/en/client-simulated/",permalink:"/ethereum-development-with-go-book/docs/en/client-simulated/",editUrl:"https://github.com/mhxw/ethereum-development-with-go-book/tree/dev/docs/en/client-simulated/README.md",tags:[],version:"current",frontMatter:{description:"Tutorial on how to set up a simulated backend as your client to test your Ethereum application with Go."},sidebar:"en",previous:{title:"Faucets",permalink:"/ethereum-development-with-go-book/docs/en/faucets/"},next:{title:"Swarm",permalink:"/ethereum-development-with-go-book/docs/en/swarm/"}},u={},d=[{value:"Full code",id:"full-code",level:3}],m={toc:d};function p(e){var n=e.components,t=(0,a.Z)(e,o);return(0,i.kt)("wrapper",(0,r.Z)({},m,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"using-a-simulated-client"},"Using a Simulated Client"),(0,i.kt)("p",null,"You can use a simulated client for testing your transactions locally quickly and easily, ideal for unit tests. In order to get started we're going to need an account with some initial ETH in it. To do that first generate an account private key."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},"privateKey, err := crypto.GenerateKey()\nif err != nil {\n  log.Fatal(err)\n}\n")),(0,i.kt)("p",null,"Then create a ",(0,i.kt)("inlineCode",{parentName:"p"},"NewKeyedTransactor")," from the ",(0,i.kt)("inlineCode",{parentName:"p"},"accounts/abi/bind")," package passing the private key."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},"auth := bind.NewKeyedTransactor(privateKey)\n")),(0,i.kt)("p",null,"The next step is to create a genesis account and assign it an initial balance. We'll be using the ",(0,i.kt)("inlineCode",{parentName:"p"},"GenesisAccount")," type from the ",(0,i.kt)("inlineCode",{parentName:"p"},"core")," package."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'balance := new(big.Int)\nbalance.SetString("10000000000000000000", 10) // 10 eth in wei\n\naddress := auth.From\ngenesisAlloc := map[common.Address]core.GenesisAccount{\n  address: {\n    Balance: balance,\n  },\n}\n')),(0,i.kt)("p",null,"Now we pass the genesis allocation struct and a configured block gas limit to the ",(0,i.kt)("inlineCode",{parentName:"p"},"NewSimulatedBackend")," method from the ",(0,i.kt)("inlineCode",{parentName:"p"},"accounts/abi/bind/backends")," package which will return a new simulated ethereum client."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},"blockGasLimit := uint64(4712388)\nclient := backends.NewSimulatedBackend(genesisAlloc, blockGasLimit)\n")),(0,i.kt)("p",null,"You can use this client as you'd normally would. As an example, we'll construct a new transaction and broadcast it."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'fromAddress := auth.From\nnonce, err := client.PendingNonceAt(context.Background(), fromAddress)\nif err != nil {\n  log.Fatal(err)\n}\n\nvalue := big.NewInt(1000000000000000000) // in wei (1 eth)\ngasLimit := uint64(21000)                // in units\ngasPrice, err := client.SuggestGasPrice(context.Background())\nif err != nil {\n  log.Fatal(err)\n}\n\ntoAddress := common.HexToAddress("0x4592d8f8d7b001e72cb26a73e4fa1806a51ac79d")\nvar data []byte\ntx := types.NewTransaction(nonce, toAddress, value, gasLimit, gasPrice, data)\nsignedTx, err := types.SignTx(tx, types.HomesteadSigner{}, privateKey)\nif err != nil {\n  log.Fatal(err)\n}\n\nerr = client.SendTransaction(context.Background(), signedTx)\nif err != nil {\n  log.Fatal(err)\n}\n\nfmt.Printf("tx sent: %s\\n", signedTx.Hash().Hex()) // tx sent: 0xec3ceb05642c61d33fa6c951b54080d1953ac8227be81e7b5e4e2cfed69eeb51\n')),(0,i.kt)("p",null,"By now you're probably wondering when will the transaction actually get mined. Well in order to \"mine\" it, there's one additional important thing you must do; call ",(0,i.kt)("inlineCode",{parentName:"p"},"Commit")," on the client to commit a new mined block."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},"client.Commit()\n")),(0,i.kt)("p",null,"Now you can fetch the transaction receipt and see that it was processed."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'receipt, err := client.TransactionReceipt(context.Background(), signedTx.Hash())\nif err != nil {\n  log.Fatal(err)\n}\nif receipt == nil {\n  log.Fatal("receipt is nil. Forgot to commit?")\n}\n\nfmt.Printf("status: %v\\n", receipt.Status) // status: 1\n')),(0,i.kt)("p",null,"So remember that the simulated client allows you to manually mine blocks at your command using the simulated client's ",(0,i.kt)("inlineCode",{parentName:"p"},"Commit")," method."),(0,i.kt)("hr",null),(0,i.kt)("h3",{id:"full-code"},"Full code"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/mhxw/ethereum-development-with-go-book/blob/main/code/client_simulated.go"},"client_simulated.go")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nimport (\n    "context"\n    "fmt"\n    "log"\n    "math/big"\n\n    "github.com/ethereum/go-ethereum/accounts/abi/bind"\n    "github.com/ethereum/go-ethereum/accounts/abi/bind/backends"\n    "github.com/ethereum/go-ethereum/common"\n    "github.com/ethereum/go-ethereum/core"\n    "github.com/ethereum/go-ethereum/core/types"\n    "github.com/ethereum/go-ethereum/crypto"\n)\n\nfunc main() {\n    privateKey, err := crypto.GenerateKey()\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    auth := bind.NewKeyedTransactor(privateKey)\n\n    balance := new(big.Int)\n    balance.SetString("10000000000000000000", 10) // 10 eth in wei\n\n    address := auth.From\n    genesisAlloc := map[common.Address]core.GenesisAccount{\n        address: {\n            Balance: balance,\n        },\n    }\n\n    blockGasLimit := uint64(4712388)\n    client := backends.NewSimulatedBackend(genesisAlloc, blockGasLimit)\n\n    fromAddress := auth.From\n    nonce, err := client.PendingNonceAt(context.Background(), fromAddress)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    value := big.NewInt(1000000000000000000) // in wei (1 eth)\n    gasLimit := uint64(21000)                // in units\n    gasPrice, err := client.SuggestGasPrice(context.Background())\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    toAddress := common.HexToAddress("0x4592d8f8d7b001e72cb26a73e4fa1806a51ac79d")\n    var data []byte\n    tx := types.NewTransaction(nonce, toAddress, value, gasLimit, gasPrice, data)\n    signedTx, err := types.SignTx(tx, types.HomesteadSigner{}, privateKey)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    err = client.SendTransaction(context.Background(), signedTx)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    fmt.Printf("tx sent: %s\\n", signedTx.Hash().Hex()) // tx sent: 0xec3ceb05642c61d33fa6c951b54080d1953ac8227be81e7b5e4e2cfed69eeb51\n\n    client.Commit()\n\n    receipt, err := client.TransactionReceipt(context.Background(), signedTx.Hash())\n    if err != nil {\n        log.Fatal(err)\n    }\n    if receipt == nil {\n        log.Fatal("receipt is nil. Forgot to commit?")\n    }\n\n    fmt.Printf("status: %v\\n", receipt.Status) // status: 1\n}\n')))}p.isMDXComponent=!0}}]);