"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[9675],{3905:function(e,t,n){n.d(t,{Zo:function(){return s},kt:function(){return g}});var r=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=r.createContext({}),u=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},s=function(e){var t=u(e.components);return r.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},h=r.forwardRef((function(e,t){var n=e.components,i=e.mdxType,a=e.originalType,l=e.parentName,s=c(e,["components","mdxType","originalType","parentName"]),h=u(n),g=i,y=h["".concat(l,".").concat(g)]||h[g]||p[g]||a;return n?r.createElement(y,o(o({ref:t},s),{},{components:n})):r.createElement(y,o({ref:t},s))}));function g(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=n.length,o=new Array(a);o[0]=h;var c={};for(var l in t)hasOwnProperty.call(t,l)&&(c[l]=t[l]);c.originalType=e,c.mdxType="string"==typeof e?e:i,o[1]=c;for(var u=2;u<a;u++)o[u]=n[u];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}h.displayName="MDXCreateElement"},1723:function(e,t,n){n.r(t),n.d(t,{assets:function(){return s},contentTitle:function(){return l},default:function(){return g},frontMatter:function(){return c},metadata:function(){return u},toc:function(){return p}});var r=n(7462),i=n(3366),a=(n(7294),n(3905)),o=["components"],c={description:"Tutorial on how to verify signatures with Go."},l="Verifying a Signature",u={unversionedId:"en/signature-verify/README",id:"en/signature-verify/README",title:"Verifying a Signature",description:"Tutorial on how to verify signatures with Go.",source:"@site/docs/en/signature-verify/README.md",sourceDirName:"en/signature-verify",slug:"/en/signature-verify/",permalink:"/ethereum-development-with-go-book/docs/en/signature-verify/",editUrl:"https://github.com/mhxw/ethereum-development-with-go-book/tree/dev/docs/en/signature-verify/README.md",tags:[],version:"current",frontMatter:{description:"Tutorial on how to verify signatures with Go."},sidebar:"en",previous:{title:"Generating a Signature",permalink:"/ethereum-development-with-go-book/docs/en/signature-generate/"},next:{title:"Testing",permalink:"/ethereum-development-with-go-book/docs/en/test/"}},s={},p=[{value:"Full code",id:"full-code",level:3}],h={toc:p};function g(e){var t=e.components,n=(0,i.Z)(e,o);return(0,a.kt)("wrapper",(0,r.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"verifying-a-signature"},"Verifying a Signature"),(0,a.kt)("p",null,"In the previous section we learned how to sign a piece of data with a private key in order to generate a signature. Now we'll learn how to verify the authenticity of the signature."),(0,a.kt)("p",null,"We need to have 3 things to verify the signature: the signature, the hash of the original data, and the public key of the signer. With this information we can determine if the private key holder of the public key pair did indeed sign the message."),(0,a.kt)("p",null,"First we'll need the public key in bytes format."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},"publicKeyBytes := crypto.FromECDSAPub(publicKeyECDSA)\n")),(0,a.kt)("p",null,"Next we'll need the original data hashed. In the previous lesson we used Keccak-256 to generate the hash, so we'll do the same in order to verify the signature."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'data := []byte("hello")\nhash := crypto.Keccak256Hash(data)\nfmt.Println(hash.Hex()) // 0x1c8aff950685c2ed4bc3174f3472287b56d9517b9c948127319a09a7a36deac8\n')),(0,a.kt)("p",null,"Now assuming we have the signature in bytes format, we can call ",(0,a.kt)("inlineCode",{parentName:"p"},"Ecrecover")," (elliptic curve signature recover) from the go-ethereum ",(0,a.kt)("inlineCode",{parentName:"p"},"crypto")," package to retrieve the public key of the signer. This function takes in the hash and signature in bytes format."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},"sigPublicKey, err := crypto.Ecrecover(hash.Bytes(), signature)\nif err != nil {\n  log.Fatal(err)\n}\n")),(0,a.kt)("p",null,"To verify we simply now have to compare the signature's public key with the expected public key and if they match then the expected public key holder is indeed the signer of the original message."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},"matches := bytes.Equal(sigPublicKey, publicKeyBytes)\nfmt.Println(matches) // true\n")),(0,a.kt)("p",null,"There's also the ",(0,a.kt)("inlineCode",{parentName:"p"},"SigToPub")," method which does the same thing except it'll return the signature's public key in the ECDSA type."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},"sigPublicKeyECDSA, err := crypto.SigToPub(hash.Bytes(), signature)\nif err != nil {\n  log.Fatal(err)\n}\n\nsigPublicKeyBytes := crypto.FromECDSAPub(sigPublicKeyECDSA)\nmatches = bytes.Equal(sigPublicKeyBytes, publicKeyBytes)\nfmt.Println(matches) // true\n")),(0,a.kt)("p",null,"For convenience, the crypto package provides the ",(0,a.kt)("inlineCode",{parentName:"p"},"VerifySignature")," function which takes in the signature, hash of the original data, and the public key in bytes format. It returns a boolean which will be true if the public key matches the signature's signer. An important gotcha is that we must first remove the last byte of the signture because it's the ECDSA recover ID which must not be included."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},"signatureNoRecoverID := signature[:len(signature)-1] // remove recovery ID\nverified := crypto.VerifySignature(publicKeyBytes, hash.Bytes(), signatureNoRecoverID)\nfmt.Println(verified) // true\n")),(0,a.kt)("p",null,"These are the basics in generating and verifying ECDSA signatures with the go-ethereum package."),(0,a.kt)("hr",null),(0,a.kt)("h3",{id:"full-code"},"Full code"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://github.com/mhxw/ethereum-development-with-go-book/blob/main/code/signature_verify.go"},"signature_verify.go")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nimport (\n    "bytes"\n    "crypto/ecdsa"\n    "fmt"\n    "log"\n\n    "github.com/ethereum/go-ethereum/common/hexutil"\n    "github.com/ethereum/go-ethereum/crypto"\n)\n\nfunc main() {\n    privateKey, err := crypto.HexToECDSA("fad9c8855b740a0b7ed4c221dbad0f33a83a49cad6b3fe8d5817ac83d38b6a19")\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    publicKey := privateKey.Public()\n    publicKeyECDSA, ok := publicKey.(*ecdsa.PublicKey)\n    if !ok {\n        log.Fatal("cannot assert type: publicKey is not of type *ecdsa.PublicKey")\n    }\n\n    publicKeyBytes := crypto.FromECDSAPub(publicKeyECDSA)\n\n    data := []byte("hello")\n    hash := crypto.Keccak256Hash(data)\n    fmt.Println(hash.Hex()) // 0x1c8aff950685c2ed4bc3174f3472287b56d9517b9c948127319a09a7a36deac8\n\n    signature, err := crypto.Sign(hash.Bytes(), privateKey)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    fmt.Println(hexutil.Encode(signature)) // 0x789a80053e4927d0a898db8e065e948f5cf086e32f9ccaa54c1908e22ac430c62621578113ddbb62d509bf6049b8fb544ab06d36f916685a2eb8e57ffadde02301\n\n    sigPublicKey, err := crypto.Ecrecover(hash.Bytes(), signature)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    matches := bytes.Equal(sigPublicKey, publicKeyBytes)\n    fmt.Println(matches) // true\n\n    sigPublicKeyECDSA, err := crypto.SigToPub(hash.Bytes(), signature)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    sigPublicKeyBytes := crypto.FromECDSAPub(sigPublicKeyECDSA)\n    matches = bytes.Equal(sigPublicKeyBytes, publicKeyBytes)\n    fmt.Println(matches) // true\n\n    signatureNoRecoverID := signature[:len(signature)-1] // remove recovery id\n    verified := crypto.VerifySignature(publicKeyBytes, hash.Bytes(), signatureNoRecoverID)\n    fmt.Println(verified) // true\n}\n')))}g.isMDXComponent=!0}}]);