"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[8096],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return m}});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),s=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=s(e.components);return r.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,u=c(e,["components","mdxType","originalType","parentName"]),d=s(n),m=a,g=d["".concat(l,".").concat(m)]||d[m]||p[m]||o;return n?r.createElement(g,i(i({ref:t},u),{},{components:n})):r.createElement(g,i({ref:t},u))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=d;var c={};for(var l in t)hasOwnProperty.call(t,l)&&(c[l]=t[l]);c.originalType=e,c.mdxType="string"==typeof e?e:a,i[1]=c;for(var s=2;s<o;s++)i[s]=n[s];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},227:function(e,t,n){n.r(t),n.d(t,{assets:function(){return u},contentTitle:function(){return l},default:function(){return m},frontMatter:function(){return c},metadata:function(){return s},toc:function(){return p}});var r=n(7462),a=n(3366),o=(n(7294),n(3905)),i=["components"],c={description:"Tutorial on how to read smart contract events with Go."},l="Reading Event Logs",s={unversionedId:"en/event-read/README",id:"en/event-read/README",title:"Reading Event Logs",description:"Tutorial on how to read smart contract events with Go.",source:"@site/docs/en/event-read/README.md",sourceDirName:"en/event-read",slug:"/en/event-read/",permalink:"/ethereum-development-with-go-book/docs/en/event-read/",editUrl:"https://github.com/mhxw/ethereum-development-with-go-book/tree/dev/docs/en/event-read/README.md",tags:[],version:"current",frontMatter:{description:"Tutorial on how to read smart contract events with Go."},sidebar:"en",previous:{title:"Subscribing to Event Logs",permalink:"/ethereum-development-with-go-book/docs/en/event-subscribe/"},next:{title:"Reading ERC-20 Token Event Logs",permalink:"/ethereum-development-with-go-book/docs/en/event-read-erc20/"}},u={},p=[{value:"Topics",id:"topics",level:3},{value:"Full code",id:"full-code",level:3}],d={toc:p};function m(e){var t=e.components,n=(0,a.Z)(e,i);return(0,o.kt)("wrapper",(0,r.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"reading-event-logs"},"Reading Event Logs"),(0,o.kt)("p",null,'A smart contract may optionally emit "events" which get stored as logs as part of the transaction receipt. Reading these events is pretty simple. First we need to construct a filter query. We import the ',(0,o.kt)("inlineCode",{parentName:"p"},"FilterQuery")," struct from the go-ethereum package and initialize it with filter options. We tell it the range of blocks that we want to filter through and specify the contract address to read these logs from. In this example we'll be reading all the logs from a particular block, from the smart contract we created in the ",(0,o.kt)("a",{parentName:"p",href:"../smart-contract-compile"},"smart contract sections"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"query := ethereum.FilterQuery{\n  FromBlock: big.NewInt(2394201),\n  ToBlock:   big.NewInt(2394201),\n  Addresses: []common.Address{\n    contractAddress,\n  },\n}\n")),(0,o.kt)("p",null,"The next is step is to call ",(0,o.kt)("inlineCode",{parentName:"p"},"FilterLogs")," from the ethclient that takes in our query and will return all the matching event logs."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"logs, err := client.FilterLogs(context.Background(), query)\nif err != nil {\n  log.Fatal(err)\n}\n")),(0,o.kt)("p",null,"All the logs returned will be ABI encoded so by themselves they won't be very readable. In order to decode the logs we'll need to import our smart contract ABI. To do that, we import our compiled smart contract Go package which will contain an external property in the name format ",(0,o.kt)("inlineCode",{parentName:"p"},"<ContractName>ABI")," containing our ABI. Afterwards we use the ",(0,o.kt)("inlineCode",{parentName:"p"},"abi.JSON")," function from the go-ethereum ",(0,o.kt)("inlineCode",{parentName:"p"},"accounts/abi")," go-ethereum package to return a parsed ABI interface that we can use in our Go application."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"contractAbi, err := abi.JSON(strings.NewReader(string(store.StoreABI)))\nif err != nil {\n  log.Fatal(err)\n}\n")),(0,o.kt)("p",null,"Now we can interate through the logs and decode them into a type we can use. If you recall the logs that our sample contract emitted were of type ",(0,o.kt)("inlineCode",{parentName:"p"},"bytes32")," in Solidity, so the equivalent in Go would be ",(0,o.kt)("inlineCode",{parentName:"p"},"[32]byte"),". We can create an anonymous struct with these types and pass a pointer as the first argument to the ",(0,o.kt)("inlineCode",{parentName:"p"},"Unpack")," function of the parsed ABI interface to decode the raw log data. The second argument is the name of the event we're trying to decode and the last argument is the encoded log data."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'for _, vLog := range logs {\n  event := struct {\n    Key   [32]byte\n    Value [32]byte\n  }{}\n  err := contractAbi.Unpack(&event, "ItemSet", vLog.Data)\n  if err != nil {\n    log.Fatal(err)\n  }\n\n  fmt.Println(string(event.Key[:]))   // foo\n  fmt.Println(string(event.Value[:])) // bar\n}\n')),(0,o.kt)("p",null,"Also, the log struct contains additional information such as the block hash, block number, and transaction hash."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"fmt.Println(vLog.BlockHash.Hex()) // 0x3404b8c050aa0aacd0223e91b5c32fee6400f357764771d0684fa7b3f448f1a8\nfmt.Println(vLog.BlockNumber)     // 2394201\nfmt.Println(vLog.TxHash.Hex())    // 0x280201eda63c9ff6f305fcee51d5eb86167fab40ca3108ec784e8652a0e2b1a6\n")),(0,o.kt)("h3",{id:"topics"},"Topics"),(0,o.kt)("p",null,"If your solidity event contains ",(0,o.kt)("inlineCode",{parentName:"p"},"indexed")," event types, then they become a ",(0,o.kt)("em",{parentName:"p"},"topic")," rather than part of the data property of the log. In solidity you may only have up to 4 topics but only 3 indexed event types. The first topic is ",(0,o.kt)("em",{parentName:"p"},"always")," the signature of the event. Our example contract didn't contain indexed events, but if it did this is how to read the event topics."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"var topics [4]string\nfor i := range vLog.Topics {\n  topics[i] = vLog.Topics[i].Hex()\n}\n\nfmt.Println(topics[0]) // 0xe79e73da417710ae99aa2088575580a60415d359acfad9cdd3382d59c80281d4\n")),(0,o.kt)("p",null,"As you can see here the first topic is just the hashed event signature."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'eventSignature := []byte("ItemSet(bytes32,bytes32)")\nhash := crypto.Keccak256Hash(eventSignature)\nfmt.Println(hash.Hex()) // 0xe79e73da417710ae99aa2088575580a60415d359acfad9cdd3382d59c80281d4\n')),(0,o.kt)("p",null,"That's all there is to reading and parsing logs. To learn how to subscribe to logs, read the ",(0,o.kt)("a",{parentName:"p",href:"../event-subscribe"},"previous section"),"."),(0,o.kt)("hr",null),(0,o.kt)("h3",{id:"full-code"},"Full code"),(0,o.kt)("p",null,"Commands"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"solc --abi Store.sol\nsolc --bin Store.sol\nabigen --bin=Store_sol_Store.bin --abi=Store_sol_Store.abi --pkg=store --out=Store.go\n")),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://github.com/mhxw/ethereum-development-with-go-book/blob/main/code/contracts/Store.sol"},"Store.sol")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"pragma solidity ^0.4.24;\n\ncontract Store {\n  event ItemSet(bytes32 key, bytes32 value);\n\n  string public version;\n  mapping (bytes32 => bytes32) public items;\n\n  constructor(string _version) public {\n    version = _version;\n  }\n\n  function setItem(bytes32 key, bytes32 value) external {\n    items[key] = value;\n    emit ItemSet(key, value);\n  }\n}\n")),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://github.com/mhxw/ethereum-development-with-go-book/blob/main/code/event_read.go"},"event_read.go")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nimport (\n    "context"\n    "fmt"\n    "log"\n    "math/big"\n    "strings"\n\n    "github.com/ethereum/go-ethereum"\n    "github.com/ethereum/go-ethereum/accounts/abi"\n    "github.com/ethereum/go-ethereum/common"\n    "github.com/ethereum/go-ethereum/crypto"\n    "github.com/ethereum/go-ethereum/ethclient"\n\n    store "./contracts" // for demo\n)\n\nfunc main() {\n    client, err := ethclient.Dial("wss://rinkeby.infura.io/ws")\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    contractAddress := common.HexToAddress("0x147B8eb97fD247D06C4006D269c90C1908Fb5D54")\n    query := ethereum.FilterQuery{\n        FromBlock: big.NewInt(2394201),\n        ToBlock:   big.NewInt(2394201),\n        Addresses: []common.Address{\n            contractAddress,\n        },\n    }\n\n    logs, err := client.FilterLogs(context.Background(), query)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    contractAbi, err := abi.JSON(strings.NewReader(string(store.StoreABI)))\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    for _, vLog := range logs {\n        fmt.Println(vLog.BlockHash.Hex()) // 0x3404b8c050aa0aacd0223e91b5c32fee6400f357764771d0684fa7b3f448f1a8\n        fmt.Println(vLog.BlockNumber)     // 2394201\n        fmt.Println(vLog.TxHash.Hex())    // 0x280201eda63c9ff6f305fcee51d5eb86167fab40ca3108ec784e8652a0e2b1a6\n\n        event := struct {\n            Key   [32]byte\n            Value [32]byte\n        }{}\n        err := contractAbi.Unpack(&event, "ItemSet", vLog.Data)\n        if err != nil {\n            log.Fatal(err)\n        }\n\n        fmt.Println(string(event.Key[:]))   // foo\n        fmt.Println(string(event.Value[:])) // bar\n\n        var topics [4]string\n        for i := range vLog.Topics {\n            topics[i] = vLog.Topics[i].Hex()\n        }\n\n        fmt.Println(topics[0]) // 0xe79e73da417710ae99aa2088575580a60415d359acfad9cdd3382d59c80281d4\n    }\n\n    eventSignature := []byte("ItemSet(bytes32,bytes32)")\n    hash := crypto.Keccak256Hash(eventSignature)\n    fmt.Println(hash.Hex()) // 0xe79e73da417710ae99aa2088575580a60415d359acfad9cdd3382d59c80281d4\n}\n')),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"$ solc --version\n0.4.24+commit.e67f0147.Emscripten.clang\n")))}m.isMDXComponent=!0}}]);