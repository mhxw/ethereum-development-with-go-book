"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[3938],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return m}});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=r.createContext({}),l=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=l(e.components);return r.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,u=c(e,["components","mdxType","originalType","parentName"]),d=l(n),m=a,f=d["".concat(s,".").concat(m)]||d[m]||p[m]||o;return n?r.createElement(f,i(i({ref:t},u),{},{components:n})):r.createElement(f,i({ref:t},u))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=d;var c={};for(var s in t)hasOwnProperty.call(t,s)&&(c[s]=t[s]);c.originalType=e,c.mdxType="string"==typeof e?e:a,i[1]=c;for(var l=2;l<o;l++)i[l]=n[l];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},4210:function(e,t,n){n.r(t),n.d(t,{assets:function(){return u},contentTitle:function(){return s},default:function(){return m},frontMatter:function(){return c},metadata:function(){return l},toc:function(){return p}});var r=n(7462),a=n(3366),o=(n(7294),n(3905)),i=["components"],c={description:"Tutorial on how to create a raw Ethereum transaction with Go."},s="Create Raw Transaction",l={unversionedId:"en/transaction-raw-create/README",id:"en/transaction-raw-create/README",title:"Create Raw Transaction",description:"Tutorial on how to create a raw Ethereum transaction with Go.",source:"@site/docs/en/transaction-raw-create/README.md",sourceDirName:"en/transaction-raw-create",slug:"/en/transaction-raw-create/",permalink:"/ethereum-development-with-go-book/docs/en/transaction-raw-create/",editUrl:"https://github.com/mhxw/ethereum-development-with-go-book/tree/dev/docs/en/transaction-raw-create/README.md",tags:[],version:"current",frontMatter:{description:"Tutorial on how to create a raw Ethereum transaction with Go."},sidebar:"en",previous:{title:"Subscribing to New Blocks",permalink:"/ethereum-development-with-go-book/docs/en/block-subscribe/"},next:{title:"Send Raw Transaction",permalink:"/ethereum-development-with-go-book/docs/en/transaction-raw-send/"}},u={},p=[{value:"Full code",id:"full-code",level:3}],d={toc:p};function m(e){var t=e.components,n=(0,a.Z)(e,i);return(0,o.kt)("wrapper",(0,r.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"create-raw-transaction"},"Create Raw Transaction"),(0,o.kt)("p",null,"If you've read the ",(0,o.kt)("a",{parentName:"p",href:"../transfer-eth"},"previous sections"),", then you know how to load your private key to sign transactions. We'll assume you know how to do that by now and now you want to get the raw transaction data to be able to broadcast it at a later time."),(0,o.kt)("p",null,"First construct the transaction object and sign it, for example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"tx := types.NewTransaction(nonce, toAddress, value, gasLimit, gasPrice, data)\n\nsignedTx, err := types.SignTx(tx, types.NewEIP155Signer(chainID), privateKey)\nif err != nil {\n  log.Fatal(err)\n}\n")),(0,o.kt)("p",null,"Now before we can get the transaction in raw bytes format we'll need to initialize a ",(0,o.kt)("inlineCode",{parentName:"p"},"types.Transactions")," type with the signed transaction as the first value."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"ts := types.Transactions{signedTx}\n")),(0,o.kt)("p",null,"The reason for doing this is because the ",(0,o.kt)("inlineCode",{parentName:"p"},"Transactions")," type provides a ",(0,o.kt)("inlineCode",{parentName:"p"},"GetRlp")," method for returning the transaction in RLP encoded format. RLP is a special encoding method Ethereum uses for serializing objects. The result of this is raw bytes."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"rawTxBytes := ts.GetRlp(0)\n")),(0,o.kt)("p",null,"Finally we can very easily turn the raw bytes into a hex string."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"rawTxHex := hex.EncodeToString(rawTxBytes)\n\nfmt.Printf(rawTxHex)\n// f86d8202b38477359400825208944592d8f8d7b001e72cb26a73e4fa1806a51ac79d880de0b6b3a7640000802ba0699ff162205967ccbabae13e07cdd4284258d46ec1051a70a51be51ec2bc69f3a04e6944d508244ea54a62ebf9a72683eeadacb73ad7c373ee542f1998147b220e\n")),(0,o.kt)("p",null,"And now you have the raw transaction data which you can use to broadcast at a future date. In the ",(0,o.kt)("a",{parentName:"p",href:"../transaction-raw-send"},"next section")," we'll learn how to broadcast a raw transaction."),(0,o.kt)("hr",null),(0,o.kt)("h3",{id:"full-code"},"Full code"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://github.com/mhxw/ethereum-development-with-go-book/blob/main/code/transaction_raw_create.go"},"transaction_raw_create.go")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nimport (\n    "context"\n    "crypto/ecdsa"\n    "encoding/hex"\n    "fmt"\n    "log"\n    "math/big"\n\n    "github.com/ethereum/go-ethereum/common"\n    "github.com/ethereum/go-ethereum/core/types"\n    "github.com/ethereum/go-ethereum/crypto"\n    "github.com/ethereum/go-ethereum/ethclient"\n)\n\nfunc main() {\n    client, err := ethclient.Dial("https://rinkeby.infura.io")\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    privateKey, err := crypto.HexToECDSA("fad9c8855b740a0b7ed4c221dbad0f33a83a49cad6b3fe8d5817ac83d38b6a19")\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    publicKey := privateKey.Public()\n    publicKeyECDSA, ok := publicKey.(*ecdsa.PublicKey)\n    if !ok {\n        log.Fatal("cannot assert type: publicKey is not of type *ecdsa.PublicKey")\n    }\n\n    fromAddress := crypto.PubkeyToAddress(*publicKeyECDSA)\n    nonce, err := client.PendingNonceAt(context.Background(), fromAddress)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    value := big.NewInt(1000000000000000000) // in wei (1 eth)\n    gasLimit := uint64(21000)                // in units\n    gasPrice, err := client.SuggestGasPrice(context.Background())\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    toAddress := common.HexToAddress("0x4592d8f8d7b001e72cb26a73e4fa1806a51ac79d")\n    var data []byte\n    tx := types.NewTransaction(nonce, toAddress, value, gasLimit, gasPrice, data)\n\n    chainID, err := client.NetworkID(context.Background())\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    signedTx, err := types.SignTx(tx, types.NewEIP155Signer(chainID), privateKey)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    ts := types.Transactions{signedTx}\n    rawTxBytes := ts.GetRlp(0)\n    rawTxHex := hex.EncodeToString(rawTxBytes)\n\n    fmt.Printf(rawTxHex) // f86...772\n}\n')))}m.isMDXComponent=!0}}]);