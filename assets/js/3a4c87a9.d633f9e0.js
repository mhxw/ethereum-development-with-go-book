"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[7526],{3905:function(e,n,t){t.d(n,{Zo:function(){return p},kt:function(){return m}});var r=t(7294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,r,o=function(e,n){if(null==e)return{};var t,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var c=r.createContext({}),i=function(e){var n=r.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},p=function(e){var n=i(e.components);return r.createElement(c.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},g=r.forwardRef((function(e,n){var t=e.components,o=e.mdxType,a=e.originalType,c=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),g=i(t),m=o,u=g["".concat(c,".").concat(m)]||g[m]||d[m]||a;return t?r.createElement(u,s(s({ref:n},p),{},{components:t})):r.createElement(u,s({ref:n},p))}));function m(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var a=t.length,s=new Array(a);s[0]=g;var l={};for(var c in n)hasOwnProperty.call(n,c)&&(l[c]=n[c]);l.originalType=e,l.mdxType="string"==typeof e?e:o,s[1]=l;for(var i=2;i<a;i++)s[i]=t[i];return r.createElement.apply(null,s)}return r.createElement.apply(null,t)}g.displayName="MDXCreateElement"},5396:function(e,n,t){t.r(n),t.d(n,{assets:function(){return p},contentTitle:function(){return c},default:function(){return m},frontMatter:function(){return l},metadata:function(){return i},toc:function(){return d}});var r=t(7462),o=t(3366),a=(t(7294),t(3905)),s=["components"],l={description:"Tutorial on how to read ERC-20 Token smart contract events with Go."},c="Reading ERC-20 Token Event Logs",i={unversionedId:"en/event-read-erc20/README",id:"en/event-read-erc20/README",title:"Reading ERC-20 Token Event Logs",description:"Tutorial on how to read ERC-20 Token smart contract events with Go.",source:"@site/docs/en/event-read-erc20/README.md",sourceDirName:"en/event-read-erc20",slug:"/en/event-read-erc20/",permalink:"/ethereum-development-with-go-book/docs/en/event-read-erc20/",editUrl:"https://github.com/mhxw/ethereum-development-with-go-book/tree/dev/docs/en/event-read-erc20/README.md",tags:[],version:"current",frontMatter:{description:"Tutorial on how to read ERC-20 Token smart contract events with Go."},sidebar:"en",previous:{title:"Reading Event Logs",permalink:"/ethereum-development-with-go-book/docs/en/event-read/"},next:{title:"Reading 0x Protocol Event Logs",permalink:"/ethereum-development-with-go-book/docs/en/event-read-0xprotocol/"}},p={},d=[{value:"Full code",id:"full-code",level:3}],g={toc:d};function m(e){var n=e.components,t=(0,o.Z)(e,s);return(0,a.kt)("wrapper",(0,r.Z)({},g,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"reading-erc-20-token-event-logs"},"Reading ERC-20 Token Event Logs"),(0,a.kt)("p",null,"First create the ERC-20 smart contract interface for event logs as ",(0,a.kt)("inlineCode",{parentName:"p"},"erc20.sol"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"pragma solidity ^0.4.24;\n\ncontract ERC20 {\n    event Transfer(address indexed from, address indexed to, uint tokens);\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n}\n")),(0,a.kt)("p",null,"Then use ",(0,a.kt)("inlineCode",{parentName:"p"},"abigen")," to create the Go ",(0,a.kt)("inlineCode",{parentName:"p"},"exchange")," package given the abi:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"solc --abi erc20.sol\nabigen --abi=erc20_sol_ERC20.abi --pkg=token --out=erc20.go\n")),(0,a.kt)("p",null,"Now in our Go application let's create the struct types matching the types of the ERC-20 event log signature:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},"type LogTransfer struct {\n    From   common.Address\n    To     common.Address\n    Tokens *big.Int\n}\n\ntype LogApproval struct {\n    TokenOwner common.Address\n    Spender    common.Address\n    Tokens     *big.Int\n}\n")),(0,a.kt)("p",null,"Initialize the ethereum client:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'client, err := ethclient.Dial("https://cloudflare-eth.com")\nif err != nil {\n  log.Fatal(err)\n}\n')),(0,a.kt)("p",null,"Create a ",(0,a.kt)("inlineCode",{parentName:"p"},"FilterQuery")," passing the ERC-20 smart contract address and the desired block range. We'll be using the ",(0,a.kt)("a",{parentName:"p",href:"https://etherscan.io/token/0xe41d2489571d322189246dafa5ebde1f4699f498"},"ZRX")," token for this example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'// 0x Protocol (ZRX) token address\ncontractAddress := common.HexToAddress("0xe41d2489571d322189246dafa5ebde1f4699f498")\nquery := ethereum.FilterQuery{\n  FromBlock: big.NewInt(6383820),\n  ToBlock:   big.NewInt(6383840),\n  Addresses: []common.Address{\n    contractAddress,\n  },\n}\n')),(0,a.kt)("p",null,"Query the logs with ",(0,a.kt)("inlineCode",{parentName:"p"},"FilterLogs"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},"logs, err := client.FilterLogs(context.Background(), query)\nif err != nil {\n  log.Fatal(err)\n}\n")),(0,a.kt)("p",null,"Next we'll parse the JSON abi which we'll use unpack the raw log data later:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},"contractAbi, err := abi.JSON(strings.NewReader(string(token.TokenABI)))\nif err != nil {\n  log.Fatal(err)\n}\n")),(0,a.kt)("p",null,"In order to filter by certain log type, we need to figure out the keccak256 hash of each event log function signature. The event log function signature hash is always ",(0,a.kt)("inlineCode",{parentName:"p"},"topic[0]")," as we'll see soon. Here's how to calculate the keccak256 hash using the go-ethereum ",(0,a.kt)("inlineCode",{parentName:"p"},"crypto")," package:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'logTransferSig := []byte("Transfer(address,address,uint256)")\nLogApprovalSig := []byte("Approval(address,address,uint256)")\nlogTransferSigHash := crypto.Keccak256Hash(logTransferSig)\nlogApprovalSigHash := crypto.Keccak256Hash(LogApprovalSig)\n')),(0,a.kt)("p",null,"Now we'll iterate through all the logs and set up a switch statement to filter by event log type:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'for _, vLog := range logs {\n  fmt.Printf("Log Block Number: %d\\n", vLog.BlockNumber)\n  fmt.Printf("Log Index: %d\\n", vLog.Index)\n\n  switch vLog.Topics[0].Hex() {\n  case logTransferSigHash.Hex():\n    //\n  case logApprovalSigHash.Hex():\n    //\n  }\n}\n')),(0,a.kt)("p",null,"Now to parse the ",(0,a.kt)("inlineCode",{parentName:"p"},"Transfer")," event log we'll use ",(0,a.kt)("inlineCode",{parentName:"p"},"abi.Unpack")," to parse the raw log data into our log type struct. Unpack will not parse ",(0,a.kt)("inlineCode",{parentName:"p"},"indexed")," event types because those are stored under ",(0,a.kt)("inlineCode",{parentName:"p"},"topics"),", so for those we'll have to parse separately as seen in the example below:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'fmt.Printf("Log Name: Transfer\\n")\n\nvar transferEvent LogTransfer\n\nerr := contractAbi.Unpack(&transferEvent, "Transfer", vLog.Data)\nif err != nil {\n  log.Fatal(err)\n}\n\ntransferEvent.From = common.HexToAddress(vLog.Topics[1].Hex())\ntransferEvent.To = common.HexToAddress(vLog.Topics[2].Hex())\n\nfmt.Printf("From: %s\\n", transferEvent.From.Hex())\nfmt.Printf("To: %s\\n", transferEvent.To.Hex())\nfmt.Printf("Tokens: %s\\n", transferEvent.Tokens.String())\n')),(0,a.kt)("p",null,"Similarly for the ",(0,a.kt)("inlineCode",{parentName:"p"},"Approval")," event log:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'fmt.Printf("Log Name: Approval\\n")\n\nvar approvalEvent LogApproval\n\nerr := contractAbi.Unpack(&approvalEvent, "Approval", vLog.Data)\nif err != nil {\n  log.Fatal(err)\n}\n\napprovalEvent.TokenOwner = common.HexToAddress(vLog.Topics[1].Hex())\napprovalEvent.Spender = common.HexToAddress(vLog.Topics[2].Hex())\n\nfmt.Printf("Token Owner: %s\\n", approvalEvent.TokenOwner.Hex())\nfmt.Printf("Spender: %s\\n", approvalEvent.Spender.Hex())\nfmt.Printf("Tokens: %s\\n", approvalEvent.Tokens.String())\n')),(0,a.kt)("p",null,"Putting it all together and running it we'll see the following output:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"Log Block Number: 6383829\nLog Index: 20\nLog Name: Transfer\nFrom: 0xd03dB9CF89A9b1f856a8E1650cFD78FAF2338eB2\nTo: 0x924CD9b60F4173DCDd5254ddD38C4F9CAB68FE6b\nTokens: 2804000000000000000000\n\n\nLog Block Number: 6383831\nLog Index: 62\nLog Name: Approval\nToken Owner: 0xDD3b9186Da521AbE707B48B8f805Fb3Cd5EEe0EE\nSpender: 0xCf67d7A481CEEca0a77f658991A00366FED558F7\nTokens: 10000000000000000000000000000000000000000000000000000000000000000\n\n\nLog Block Number: 6383838\nLog Index: 13\nLog Name: Transfer\nFrom: 0xBA826fEc90CEFdf6706858E5FbaFcb27A290Fbe0\nTo: 0x4aEE792A88eDDA29932254099b9d1e06D537883f\nTokens: 2863452144424379687066\n")),(0,a.kt)("p",null,"Compare the parsed log output to what's on etherscan: ",(0,a.kt)("a",{parentName:"p",href:"https://etherscan.io/tx/0x0c3b6cf604275c7e44dc7db400428c1a39f33f0c6cbc19ff625f6057a5cb32c0#eventlog"},"https://etherscan.io/tx/0x0c3b6cf604275c7e44dc7db400428c1a39f33f0c6cbc19ff625f6057a5cb32c0#eventlog")),(0,a.kt)("hr",null),(0,a.kt)("h3",{id:"full-code"},"Full code"),(0,a.kt)("p",null,"Commands"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"solc --abi erc20.sol\nabigen --abi=erc20_sol_ERC20.abi --pkg=token --out=erc20.go\n")),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://github.com/mhxw/ethereum-development-with-go-book/blob/main/code/contracts_erc20/erc20.sol"},"erc20.sol")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"pragma solidity ^0.4.24;\n\ncontract ERC20 {\n    event Transfer(address indexed from, address indexed to, uint tokens);\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n}\n")),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://github.com/mhxw/ethereum-development-with-go-book/blob/main/code/event_read_erc20.go"},"event_read_erc20.go")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nimport (\n    "context"\n    "fmt"\n    "log"\n    "math/big"\n    "strings"\n\n    token "./contracts_erc20" // for demo\n    "github.com/ethereum/go-ethereum"\n    "github.com/ethereum/go-ethereum/accounts/abi"\n    "github.com/ethereum/go-ethereum/common"\n    "github.com/ethereum/go-ethereum/crypto"\n    "github.com/ethereum/go-ethereum/ethclient"\n)\n\n// LogTransfer ..\ntype LogTransfer struct {\n    From   common.Address\n    To     common.Address\n    Tokens *big.Int\n}\n\n// LogApproval ..\ntype LogApproval struct {\n    TokenOwner common.Address\n    Spender    common.Address\n    Tokens     *big.Int\n}\n\nfunc main() {\n    client, err := ethclient.Dial("https://cloudflare-eth.com")\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // 0x Protocol (ZRX) token address\n    contractAddress := common.HexToAddress("0xe41d2489571d322189246dafa5ebde1f4699f498")\n    query := ethereum.FilterQuery{\n        FromBlock: big.NewInt(6383820),\n        ToBlock:   big.NewInt(6383840),\n        Addresses: []common.Address{\n            contractAddress,\n        },\n    }\n\n    logs, err := client.FilterLogs(context.Background(), query)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    contractAbi, err := abi.JSON(strings.NewReader(string(token.TokenABI)))\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    logTransferSig := []byte("Transfer(address,address,uint256)")\n    LogApprovalSig := []byte("Approval(address,address,uint256)")\n    logTransferSigHash := crypto.Keccak256Hash(logTransferSig)\n    logApprovalSigHash := crypto.Keccak256Hash(LogApprovalSig)\n\n    for _, vLog := range logs {\n        fmt.Printf("Log Block Number: %d\\n", vLog.BlockNumber)\n        fmt.Printf("Log Index: %d\\n", vLog.Index)\n\n        switch vLog.Topics[0].Hex() {\n        case logTransferSigHash.Hex():\n            fmt.Printf("Log Name: Transfer\\n")\n\n            var transferEvent LogTransfer\n\n            err := contractAbi.Unpack(&transferEvent, "Transfer", vLog.Data)\n            if err != nil {\n                log.Fatal(err)\n            }\n\n            transferEvent.From = common.HexToAddress(vLog.Topics[1].Hex())\n            transferEvent.To = common.HexToAddress(vLog.Topics[2].Hex())\n\n            fmt.Printf("From: %s\\n", transferEvent.From.Hex())\n            fmt.Printf("To: %s\\n", transferEvent.To.Hex())\n            fmt.Printf("Tokens: %s\\n", transferEvent.Tokens.String())\n\n        case logApprovalSigHash.Hex():\n            fmt.Printf("Log Name: Approval\\n")\n\n            var approvalEvent LogApproval\n\n            err := contractAbi.Unpack(&approvalEvent, "Approval", vLog.Data)\n            if err != nil {\n                log.Fatal(err)\n            }\n\n            approvalEvent.TokenOwner = common.HexToAddress(vLog.Topics[1].Hex())\n            approvalEvent.Spender = common.HexToAddress(vLog.Topics[2].Hex())\n\n            fmt.Printf("Token Owner: %s\\n", approvalEvent.TokenOwner.Hex())\n            fmt.Printf("Spender: %s\\n", approvalEvent.Spender.Hex())\n            fmt.Printf("Tokens: %s\\n", approvalEvent.Tokens.String())\n        }\n\n        fmt.Printf("\\n\\n")\n    }\n}\n')),(0,a.kt)("p",null,"solc version used for these examples"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"$ solc --version\n0.4.24+commit.e67f0147.Emscripten.clang\n")))}m.isMDXComponent=!0}}]);